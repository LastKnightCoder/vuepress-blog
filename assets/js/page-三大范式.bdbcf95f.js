(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{1086:function(v,_,t){"use strict";t.r(_);var e=t(1),l=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求。设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。")]),v._v(" "),t("p",[v._v("目前关系数据库有六种范式 ： 第一范式(1NF) 、第二范式(2NF) 、第三范式(3NF) 、巴斯-科德范式(BCNF) 、第四范式(4NF)和第五范式(5NF，又称完美范式) 。满足最低要求的范式是第一范式(1NF) 。在第一范式的基础上进一步满足更多规范要求的称为第二范式(2NF) ，其余范式以次类推。一般说来，数据库只需满足第三范式(3NF)就行了。")]),v._v(" "),t("p",[v._v("为了理解三大范式，我们首先来看这么一张表")]),v._v(" "),t("img",{attrs:{src:"https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql31.png"}}),v._v(" "),t("p",[v._v("我们首先来看第一范式的概念：数据库表的每一列都是不可分割的原子数据项。即表中的某个列有多个值时，必须拆分为不同的列。上面的那个表不满足第一范式，因为系的那一列被拆成了两列，我们将它拆分成不同的列")]),v._v(" "),t("img",{attrs:{src:"https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql32.png"}}),v._v(" "),t("p",[v._v("它现在满足第一范式的要求了，接下来看第二范式的概念：在1NF的基础上，非码属性必须完全依赖于码。为了理解这句话的意思，先看下面几个概念：")]),v._v(" "),t("ol",[t("li",[v._v("函数依赖："),t("code",[v._v("A=>B")]),v._v("，如果通过 A 属性(属性组)的值，可以确定唯一 B 属性的值。则称 B 依赖于 A\n"),t("ul",[t("li",[v._v("例如：学号"),t("code",[v._v("=>")]),v._v("姓名。(学号，课程名称) "),t("code",[v._v("--\x3e")]),v._v(" 分数")])])]),v._v(" "),t("li",[v._v("完全函数依赖："),t("code",[v._v("A=>B")]),v._v("， 如果 A 是一个属性组，则 B 属性值得确定需要依赖于 A 属性组中所有的属性值。\n"),t("ul",[t("li",[v._v("例如：(学号，课程名称) "),t("code",[v._v("=>")]),v._v(" 分数")])])]),v._v(" "),t("li",[v._v("部分函数依赖："),t("code",[v._v("A=>B")]),v._v("， 如果 A 是一个属性组，则 B 属性值的确定只需要依赖于 A 属性组中某一些值即可。\n"),t("ul",[t("li",[v._v("例如：(学号，课程名称) "),t("code",[v._v("--\x3e")]),v._v(" 姓名，只依靠学号")])])]),v._v(" "),t("li",[v._v("传递函数依赖："),t("code",[v._v("A=>B")]),v._v(", "),t("code",[v._v("B=>C")]),v._v(" . 如果通过 A 属性(属性组)的值，可以确定唯一 B 属性的值，在通过 B 属性(属性组)的值可以确定唯一 C 属性的值，则称 C 传递函数依赖于 A\n"),t("ul",[t("li",[v._v("例如：学号 "),t("code",[v._v("=>")]),v._v(" 系名，系名 "),t("code",[v._v("=>")]),v._v(" 系主任")])])]),v._v(" "),t("li",[v._v("码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码\n"),t("ul",[t("li",[v._v("例如：该表中码为：(学号，课程名称)")]),v._v(" "),t("li",[v._v("主属性：码属性组中的所有属性")]),v._v(" "),t("li",[v._v("非主属性：除过码属性组的属性")])])])]),v._v(" "),t("p",[v._v("其实 2NF 就是在 1NF 基础上消除非主属性对主码的部分函数依赖，上表中的码为(学号，课程名称)，只有分数完全依赖该码组，所以我们拆分表如下，")]),v._v(" "),t("img",{attrs:{src:"https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql33.png"}}),v._v(" "),t("p",[v._v("第三范式(3NF)：在2NF基础上，任何非主属性不依赖于其它非主属性(在2NF基础上消除传递依赖)，在学生表中存在学号 "),t("code",[v._v("=>")]),v._v(" 系名 "),t("code",[v._v("=>")]),v._v(" 系主任的传递依赖，所以再次拆分表")]),v._v(" "),t("img",{attrs:{src:"https://gitee.com/lastknightcoder/blogimage/raw/master/img/mysql34.png"}}),v._v(" "),t("p",[v._v("三大范式小结")]),v._v(" "),t("ul",[t("li",[v._v("1NF: 原子性，表中每列不可再拆分。")]),v._v(" "),t("li",[v._v("2NF: 不产生局部依赖，一张表只描述一件事情")]),v._v(" "),t("li",[v._v("3NF: 不产生传递依赖，表中每一列都直接依赖于主键。而不是通过其它列间接依赖于主键。")])])])}),[],!1,null,null,null);_.default=l.exports}}]);
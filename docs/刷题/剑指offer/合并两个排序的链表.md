---
title: 合并两个排序的链表
author: 熊滔
category: 剑指offer
---

> 题目：输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。例如，输入如图中的链表 $1$ 和链表 $2$，则合并之后的升序链表如链表 $3$ 所示。链表节点定义如下：
>
> ```java
> private static class ListNode {
>        public ListNode next;
>        public int value;
>        public ListNode(int value) {
>            this.next = null;
>            this.value = value;
>        }
> }
> ```
>
> 
> <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/202006171628.svg"/>
> 

熟悉归并排序就会明白，这个过程正是归并排序的 `merge` 过程，在这个过程中，我们定义两个指针分别指向两个递增列表的开头，接着比较两个指针指向的值的大小，值较小的节点添加到新的链表中，直到其中一个指针已经指向链表的结尾，这时将另一个指针指向的节点及后续节点添加到新链表中，如下

```java
public static ListNode merge(ListNode root1, ListNode root2) {
    if (root1 == null) {
        return root2;
    }
    if (root2 == null) {
        return root1;
    }
    ListNode root = null;
    // 为了不对外部的root1和root2产生影响，使用p1和p2接收
    ListNode p1 = root1;
    ListNode p2 = root2;
    if (p1.value <= p2.value) {
        root = p1;
        p1 = p1.next;
    } else {
        root = p2;
        p2 = p2.next;
    }
    // 使用 cur 表示遍历的节点
    ListNode cur = root;
    while (p1 != null && p1 != null) {
        if (p1.value <= p2.value) {
            cur.next = p1;
            cur = cur.next;
            p1 = p1.next;
        } else {
            cur.next = p2;
            cur = cur.next;
            p2 = p2.next;
        }
    }
    // 如果 p1 为 null，则将 p2 指向的节点及后续节点添加到链表中
    if (p1 == null) {
        cur.next = p2;
    }
    // 反之，将 p1 指向的节点及后续节点添加到链表中
    if (p2 == null) {
        cur.next = p1;
    }
    return root;
}
```

我们也可以使用递归的方法

```java
public static ListNode merge(ListNode root1, ListNode root2) {
    if (root1 == null) {
        return root2;
    }
    if (root2 == null) {
        return root1;
    }
    ListNode mergeRoot = null;
    if (root1.value <= root2.value) {
        mergeRoot = root1;
        mergeRoot.next = merge(root1.next, root2);
    } else {
        mergeRoot = root2;
        mergeRoot.next = merge(root1, root2.next);
    }
    return mergeRoot;
}
```

<Disqus />
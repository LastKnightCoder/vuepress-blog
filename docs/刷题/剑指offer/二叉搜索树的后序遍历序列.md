---
title: 二叉搜索树的后序遍历序列
author: 熊滔
category: 剑指offer
---

> 题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同。例如，输入数组 `{5, 7, 6, 9, 11, 10, 8}`，则返回 `true`，因为这个整数序列是下面二叉搜索树的后序遍历的结果
>
> <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/202006270951.svg"/>
> 
> 如果输入的数组是 `{7, 4, 6, 5}`，则由于没有哪棵二叉搜索树的后序遍历结果是这个序列，所以返回 `false`。

我们来看一下二叉搜索树后序遍历序列的结构

<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/202006270950.svg"/>


后序遍历的最后一个节点是根节点，前部分是树的左子树，后部分是树的右子树。因为该树为二叉搜索树，所以左子树中的所有值都比根节点小，右子树的所有值都比根节点大。根据后序遍历的特点，我们的方法是

1. 先拿到根节点的值
2. 然后遍历数组，找到第一个比根节点大的值，即右子树的起点，接着判断右子树中是否所有值都大于根节点，如果大于根节点，那么该树可能是后序遍历，接着判断左子树和右子树的后序遍历是否符合情况
3. 如果右子树中有值小于根节点，说明该序列不可能是后序遍历序列

代码如下

```java
public boolean versifySequenceOfBST(int[] sequence, int start, int end) {
    // 先拿到根节点的值
    int root = sequence[end];
    // 拿到右子树的起始
    int index = start;
    for (; index < end; index++) {
        if (sequence[index] > root) {
            break;
        }
    }
    int mid = index;
    for (; index < end; index++) {
        // 如果右子树中有小于根节点的值，那么不可能是后序遍历的结果
        if (sequence[index] < root) {
            return false;
        }
    }
    boolean left = true;
    // mid > 0 说明有左子树
    if (mid > 0) {
        left = versifySequenceOfBST(sequence, 0, mid - 1);
    }
    boolean right = true;
    // mid < end 说明有右子树
    if (mid < end) {
        right = versifySequenceOfBST(sequence, mid, end - 1);;
    }
    
    return left && right;
}
```

<Disqus />
---
title: 丑数
author: 熊滔
category: 剑指offer
---

> 题目：我们把只包含因子 $2、3$ 和 $5$ 的数称作丑数(`Ugly Number`)，例如，$6、8$ 都是丑数，但 $14$ 不是，因为它包含因子 $7$，求按从小到大的顺序的第 $n$ 个丑数。习惯上我们把 $1$ 当作第一个丑数。

我们很容易写出判断一个数是不是丑数的代码

```java
private static boolean isUglyNumber(int n) {
    while (n % 2 == 0) {
        n = n / 2;
    }
    while (n % 3 == 0) {
        n = n / 3;
    }
    while (n % 5 == 0) {
        n = n / 5;
    }
    
    return n == 1;
}
```

所以我们可以遍历数字，直到第 $n$ 个数字

```java
public static int getUglyNumber(int n) {
    int count = 0;
    int number = 0;
    while (count < n) {
        number++;
        if (isUglyNumber(number)) {
            count++;
        }
    }
    
    return number;
}
```

这样的代码当然可以解决问题，但是效率并不是最优的。下面我们将介绍一种更快的方法，因为丑数是只包含 $2, 3, 5$ 的因子，所以丑数一定是之前的丑数乘 $2$ $3$ $5$ 得到的，所以如果我们能够保存之前出现的丑数，让它乘 $2, 3, 5$ 即可得到三个丑数，我们取最小的那个，即是最新的丑数，具体见代码

```java
public static int getUglyNumber(int index) {
    if (index <= 0) {
        return 0;
    }
    // 使用一个数组来保存丑数
    int[] uglyNumbers = new int[index];
    // 第一个丑数是 1
    uglyNumbers[0] = 1;
    // 已经乘过 2 的丑数的下标，下面同理
    int uglyNumberMultiply2Index = 0;
    int uglyNumberMultiply3Index = 0;
    int uglyNumberMultiply5Index = 0;
    for (int i = 1; i < uglyNumbers.length; i++) {
        // 取三个丑数中最小的
        int min = Math.min(uglyNumbers[uglyNumberMultiply2Index] * 2, 
        Math.min(uglyNumbers[uglyNumberMultiply3Index] * 3, uglyNumbers[uglyNumberMultiply5Index] * 5));
        
        uglyNumbers[i] = min;
        // 如果是乘的 2，那么乘 2 的丑数的下标增加，下面同理
        if (uglyNumbers[uglyNumberMultiply2Index] * 2 == min) {
            uglyNumberMultiply2Index++;
        }
        if (uglyNumbers[uglyNumberMultiply3Index] * 3 == min) {
            uglyNumberMultiply3Index++;
        }
        if (uglyNumbers[uglyNumberMultiply5Index] * 5 == min) {
            uglyNumberMultiply5Index++;
        }
    }
    return uglyNumbers[index - 1];
}
```

这种算法的效率更快，但是它需要额外的空间来存储丑数，所以这是一个使用空间换时间的算法。

<Disqus />
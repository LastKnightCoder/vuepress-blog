---
title: 二叉树的下一个节点
author: 熊滔
category: 剑指offer
---

> 题目：给定一棵二叉树和其中的一个节点，如何找出中序遍历序列的下一个节点? 树中的节点除了有两个分别指向左、右子节点的指针，还有一个指向父节点的指针。(树的中序遍历指的是先打印左子树，然后打印根节点，最后打印右子树)

我们以下图来分析二叉树的下一个节点

<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200602192821.png" style="zoom:50%;" />

其中标在节点旁边的数字表示打印的顺序，比如节点 `4` 旁边标注 `1`，表示它是第一个被打印的，它的中序遍历的结果如下

<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200602192943.png" style="zoom:50%;" />

我们分以下几种情况分析：

1. 该节点有右子树，例如节点 `4`，节点 `3`等等，那么它的下一个节点就是它右子树中最左的节点，例如节点 `4` 右子树最左的节点是 `7`，所以它的下一个节点是 `7`，节点 `3` 的右子树的最左的节点是 `8`，所以它的下一个节点是 `8`

   <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200602194252.png" />

2. 该节点没有右子树，且父节点存在，并且它是它父节点的左孩子，那么它的父节点就是它的下一个节点，所以节点 `5` 的下一个节点是节点 `3`

   <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200602194633.png" style="zoom:50%;" />

3. 该节点没有右子树，父节点存在，并且也不是它父节点的左孩子，如节点 `7`，那么它就要一直向上寻找，直到某个节点是它父节点的左孩子，此时父节点就是下一个节点。如节点 `7` 不是它父节点的左孩子，向上寻找，来到父节点 `4`，它是它父节点的左孩子，所以节点 `4` 的父节点 `2` 是节点 `7` 的下一个节点

    <img src="https://gitee.com/lastknightcoder/blogimage/raw/master/img/20200602195125.png" style="zoom:50%;" />


   如果向上寻找，没有找到某个节点是它父节点的左孩子，那么说明没有下一个节点，如节点 `6` 没有下一个节点

4. 没有右子树，且父节点不存在，没有下一个节点

完整代码如下：

```java
public class NextNode {
    // 二叉树的定义
    private static class BinaryTree {
        int value;
        // 还有一个指向父节点的指针
        BinaryTree parent;
        BinaryTree left;
        BinaryTree right;
        public BinaryTree(int value) {
            this.value = value;
        }
    }

    public static BinaryTree findNext(BinaryTree node) {
        if (node == null) {
            return null;
        }

        // 1. 如果有右子树，下一个节点是右子树的最左子树
        if (node.right != null) {
            BinaryTree next = node.right;
            while (next.left != null) {
                next = next.left;
            }
            return next;
        // 没有右子树，且父节点存在
        } else if (node.parent != null) {
            // 2. 如果是父节点的左孩子
            if (node == node.parent.left) {
                return node.parent;
            } else {
                // 3. 如果不是父节点的左孩子，向上寻找
                while (node.parent != null) {
                    // 直到找到某节点是它父节点的左孩子，父节点是下一个节点
                    if (node == node.parent.left) {
                        return node.parent;
                    }
                    node = node.parent;
                }
                // 没有找到某节点是父节点的左孩子，没有下一个节点
                return null;
            }
        // 没有右子树，也没有父节点，那么也没有下一个节点
        } else {
            return null;
        }
    }
}
```

<Disqus />
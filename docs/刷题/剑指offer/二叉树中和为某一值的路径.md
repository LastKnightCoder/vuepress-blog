---
title: 二叉树中和为某一值的路径
author: 熊滔
category: 剑指offer
---

> 题目：输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。二叉树节点的定义如下：
>
> ```java
> private static class BinaryTreeNode {
>        private BinaryTreeNode left;
>        private BinaryTreeNode right;
>        int value;
>        public BinaryTreeNode(int value) {
>            this.left = null;
>            this.right = null;
>            this.value = value;
>        }
> }
> ```

在每次访问一个节点时，我们使用容器来保存当前节点的值，接着继续进入它的左子树和右子树，当到达叶子节点时判断容器中所有值是否为输入整数的值，如果是则打印，否则不打印。当程序递归再次回到该节点时，从容器中弹出该节点的值，以如下树中查找数字 `22` 为例

<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/202006281216.svg"/>

```java
public void findPath(BinaryTreeNode root, int expectedSum) {
    if (root == null) {
        return;
    }
    Stack<Integer> path = new Stack<>();
    int currentSum = 0;
    findPath(root, expectedSum, path, currentSum);
}

private void findPath(BinaryTreeNode root, int expectedSum, Stack<Integer> path, int currentSum) {
    currentSum += root.value;
    // 每来到一个节点，将该节点的值添加到路径中
    path.push(root.value);
    // 是否是叶子节点
    boolean isLeaf = root.left == null && root.right == null;
    // 如果是叶子节点，并且路径上的值为输入的整数，则打印路径
    if (currentSum == expectedSum && isLeaf) {
        for (int i = 0; i < path.size(); i++) {
            if (i == path.size() - 1) {
                System.out.println(path.get(i));
            } else {
                System.out.print(path.get(i) + "->");
            }
        }
    }
    // 去左子树中查找
    if (root.left != null) {
        findPath(root.left, expectedSum, path, currentSum);
    }
    // 去右子树中查找
    if (root.right != null) {
        findPath(root.right, expectedSum, path, currentSum);
    }
    // 再次回到该节点时，将该节点的值从路径中删除
    path.pop();
}
```

<Disqus />
---
title: 数字序列中某一位的数字
author: 熊滔
category: 剑指offer
---

> 题目：数字以 $0123456789101112131415...$ 的格式序列化到一个字符序列中。在这个序列中，第 $5$ 位(从 $0$ 开始计数)是 $5$，第 $13$ 位是 $1$，第 $19$ 位是 $4$ 等等。请写一个函数，求任意第 $n$ 位对应的数字。

最直观的方法就是从 $0$ 开始遍历数字，并统计数字的位数，将这出现数字的位数相加起来，如果已经大于等于 $n$，那么要查找的数字肯定在最后一个数字中，接着我们在该数字中查找对应的那一位。

但是不是有更快的方法，我们可以挖掘数字出现的规律，从而跳过某些数字。比如我想查找第 $15$ 位数字，因为一位的数字只有 $10$ 个，而 $15 > 10$，所以我们完全可以跳过这 $10$ 个数字，去两位数中寻找。接着我们去两位数中寻找第 $15 - 10 = 5$ 位数字，因为两位数共有 $10-99$ 共 $90$ 个两位数，包含 $2 * 90 = 180$ 个数字，因为 $5 < 180$，所以我们要找的数字一定在这些两位数中，因为 $5 = 2 * 2 + 1$，所以要找的数字是第二个两位数(从 $0$ 开始算)的第一位(从 $0$ 开始算)，第二个两位数是 $12$，它的第一位是 $2$，所以第 $15$ 位是 $2$。

很快我们可以写出这样的代码

```java
public int digitAtIndex(int index) {
    if (index < 0) {
        return -1;
    }
    int digit = 1;
    while (true) {
        // 获得 digit 位数的个数，比如对于两位数有 90 个
        int numbers = countInteger(digit);
        // 例如 5 < 180，那么肯定在两位数中，去两位数中进行查找
        if (index < numbers * digit) {
            return digitAtIndex(index, digit);
        }
        index -= numbers * digit;
        digit++;
    }
}

private int countInteger(int digit) {
    // 一位数有10个，其他的有 90,900,9000... 个
    if (digit == 1) {
        return 10;
    }
    return (int)Math.pow(10, digit - 1) * 9;
}

private int digitAtIndex(int index, int digit) {
    // 5 = 2 * 2 + 1
    // number = 2
    int number = beginNumber(digit) + index / digit;
    // 倒着查找，即从个位数开始计算，倒数第 2 - 1 = 1 个数字
    int indexFromRight = digit - index % digit;
    for (int i = 1; i < indexFromRight; i++) {
        number /= 10;
    }
    return number % 10;
}

private int beginNumber(int digit) {
    // 一位数以 0 开始，其他的以 10,100,1000 开始
    if (digit == 1) {
        return 0;
    }
    return (int)Math.pow(10, digit - 1);
}
```

<Disqus />
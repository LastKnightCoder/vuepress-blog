---
title: 在排序数组中查找数字
author: 熊滔
category: 剑指offer
---

> 题目：统计一个数字在排序数组中出现的次数。例如，输入排序数组 $[1, 2, 3, 3, 3, 3, 4, 5]$ 和数字 $3$，由于 $3$ 在这个数组中出现了 $4$ 次，因此输出 $4$。

因为数组是排好序的，所以自然的我们会考虑使用二分查找算法，但是二分查找算法只是查找到一个数字，如果我们要统计某数字出现的次数的话，最佳的是查找到数字出现在最左边和最右边的下标，二者之间的距离就是数字在数组中出现的次数。

所以我们可以改进一下查找的过程，以查找数字出现在最左边为例，如果我们在数组查找到了数字 $3$，如果在它的左边还是数字 $3$，那么我们继续在它的左边继续使用二分查找进行查找，对于数字出现在最右边也是同样的求法。

```java
// 第一次 k 出现的位置
private int firstKNumber(int[] data, int k) {
    int start = 0;
    int end = data.length - 1;
    while (start <= end) {
        int mid = start + (end - start) / 2;
        if (data[mid] == k) {
            // 如果左边还是 k，那么在左边继续进行查找
            if (mid > 0 && data[mid - 1] == k) {
                end = mid - 1;
            } else {
                return mid;
            }
        } else if (data[mid] > k) {
            end = mid - 1;
        } else {
            start = mid + 1;
        }
    }
    return -1;
}

// 最后一次 k 出现的位置
private int lastKNumber(int[] data, int k) {
    int start = 0;
    int end = data.length - 1;
    while (start <= end) {
        int mid = start + (end -start) / 2;
        if (data[mid] == k) {
            // 如果右边还是 k，在右边继续进行查找
            if (mid < data.length - 1 && data[mid + 1] == k) {
                start = mid + 1;
            } else {
                return mid;
            }
        } else if (data[mid] > k) {
            end = mid - 1;
        } else {
            start = mid + 1;
        }
    }
    return -1;
}
```

有了上面两个方法，我们很快可以求出数字出现的次数

```java
public int getNumberOfK(int[] data, int k) {
    if (data == null || data.length == 0) {
        return 0;
    }
    int first = firstKNumber(data, k);
    int last = lastKNumber(data, k);
    // 数组中没有该数字
    if (first == -1 || last == -1) {
        return 0;
    }
    return (last - first) + 1;
}
```

> 题目：一个长度为 $n - 1$ 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围 $0 -(n  - 1)$ 之内。在范围 $0 -(n  - 1)$ 内的 $n$ 个数字中有且只有一个数字不在该数组中，请找出这个数字。

首先有一个直观的解法，首先根据公式 $n(n-1)/2$ 求出 $0-(n-1)$ 所有数字之和 $s_1$，接着遍历数组求出数组中所以数字之和 $s_2$，那么缺失的那个数字就是二者之差 $s_1 - s_2$，这种解法需要 $O(n)$ 的时间复杂度，但是这种解法没有利用数组是排好序的这一特点，所以有更好的解法。

对于排序数组，我们查找还是使用二分查找算法。假设缺失的数字是 $m$，那么对于小于 $m$ 的数字，在数组就一定会有 $nums[i] = i$，而对于大于 $m$ 的数字，就会有 $nums[i] = i + 1$，根据这个条件我们可以不断缩小查找的范围。当我们得到 $nums[i] = i$ 时，说明缺失的数字在右边，当我们得到 $nums[i] = i + 1$ 时，如果此时它左边的数字满足 $nums[i - 1] = i - 1$，说明 $i$ 就是那个缺失的数字，否则我们继续在左边进行查找

```java
public int getMissingNumber(int[] data) {
    if (data == null || data.length  == 0) {
        return -1;
    }
    int start = 0;
    int end = data.length - 1;
    while (start <= end) {
        int mid = start + (end - start) / 2;
        if (data[mid] != mid) {
            if (mid > 0 && data[mid - 1] != (mid -1 )) {
                end = mid - 1;
            } else {
                return mid;
            }
        } else {
            start = mid + 1;
        }
    }
    return -1;
}
```

> 题目：假设一个单调递增的数组里面的每个元素都是整数并且是唯一的。请编程实现一个函数，找出数组中任意一个数值等于其下标的元素。例如，在数组 $[-3, -1, 1, 3, 5]$ 中，数字 $3$ 和它的下标相等。

对于已排序好的数组查找，我们还是使用二分查找比较快。如果我们发现 $nums[i] > i$ 说明 $nums[i] = i$ 的数字在数组的左边，如果 $nums[i] < i$，说明 $nums[i] = i$ 的数字在数组的右边，通过这样我们不断减少查找的范围

```java
public int getSameIndex(int[] data) {
    if (data == null || data.length == 0) {
        return -1;
    }
    int start = 0;
    int end = data.length - 1;
    while (start <= end) {
        int mid = start + (end - start);
        if (data[mid] == mid) {
            return mid;
        } else if (data[mid] < mid) {
            // 在右边继续进行查找
            start = mid + 1;
        } else {
            // 在左边继续进行查找
            end = mid - 1;
        }
    }
    return -1;
}
```



<Disqus />
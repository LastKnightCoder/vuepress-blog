---
title: 树的子结构
author: 熊滔
category: 剑指offer
---

> 题目：输入两棵二叉树 `A` 和 `B`，判断 `B` 是不是 `A` 的子结构。二叉树节点的定义如下：
>
> ```java
> private static class BinaryTreeNode {
>        private BinaryTreeNode left;
>        private BinaryTreeNode right;
>        int value;
>        public BinaryTreeNode(int value) {
>            this.left = null;
>            this.right = null;
>            this.value = value;
>        }
> }
> ```

相对于链表，树的题目就比较难了。这道题我们可以分为两步，第一步遍历树 `A`，如果 `A` 中某节点的值与 `B` 树的根节点的值相同，那么进一步判断 `B` 的左右子树是否与该节点的左右子树相同，如果相同，则说明 `B` 是 `A` 的子结构，如果不同，则继续遍历树 `A`，如果再次找到某节点的值与 `B` 树的根节点的值相同，重复上面的过程，如果遍历完 `A` 都没有发现与 `B` 一样的子结构，那么说明 `B` 不是 `A` 的子结构。

```java
// 遍历树
public boolean hasSubTree(BinaryTreeNode root, BinaryTreeNode subRoot) {
    boolean result = false;
    if (root != null && subRoot != null) {
        // 找到某节点的值与 B 的根节点的值相同 进一步进行深入的比较
        if (root.value == subRoot.value) {
            // root 是否包含 subRoot
            result = DoesTree1HaveTree2(root, subRoot);
        }
        // 目前节点的值与B的根节点的值不同或者该节点的左右子树与B的左右子树不同
        // 进一步遍历 A 树
        if (!result) {
            result = hasSubTree(root.left, subRoot);
        }
        if (!result) {
            result = hasSubTree(root.right, subRoot);
        }
    }
    return result;
}

// root 是否包含 subRoot
private boolean DoesTree1HaveTree2(BinaryTreeNode root, BinaryTreeNode subRoot) {
    if (subRoot == null) { 
        return true;
    }
    if (root == null) {
        return false;
    }
    if (root.value != subRoot.value) {
        return false;
    }
    return DoesTree1HaveTree2(root.left, subRoot.left) && 
           DoesTree1HaveTree2(root.right, subRoot.right);
}
```



<Disqus />
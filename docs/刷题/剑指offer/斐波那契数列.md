---
title: 斐波那契数列
author: 熊滔
category: 剑指offer
---

> 题目：求斐波那契数列的第 $n$ 项。斐波那契数列的定义如下：
> $$
> f(n) = 
> \begin{cases}
> 1, & n = 1 \\
> 1, & n = 2 \\
> f(n - 1) + f(n - 2), & n > 2
> \end{cases}
> $$

斐波那契数列的定义对于大家来说应该很熟了，即斐波那契数列的第 $n$ 项的数字是前两项的和，而在高校的教科书中，斐波那契数列也是作为讲解函数递归很好的例子，所以你会很快写出这样的代码

```java
public static int fibonacci(int n) {
    if (n <= 0) {
        return 0;
    } else if (n == 1 || n == 2) {
        return 1;
    }
    return fibonacci(n -1) + fibonacci(n - 2);
}
```

但是上面的程序有个很大的问题，就是运行的速度很慢，我们先看一下运行的时间，再来分析为何这么慢

```java
public static void main(String[] args) {
    long start = System.nanoTime();
    System.out.println(fibonacci(45));
    long end = System.nanoTime();
    System.out.println((end -  start) / 1000000 + " ms");
}
```

结果如下

```java
1134903170
4272 ms
```

在我的电脑上，计算斐波那契数列第 $45$ 项所需的时间是 `4272 ms`。现在你可能不知道这个时间是快是慢，但是我们分析一下，我们计算 $f(45)$ 时，我们需要计算 $f(44)$ 和 $f(43)$，在计算 $f(44)$ 时我们又要计算 $f(43)$，说明计算重复了，经过分析它的时间复杂度是 $O(2^n)$。

现在我们考虑另一种解法，我们分析上面的计算是因为重复的计算，如果我们利用前面已有的结果，那么所需的时间即可大大减少，程序如下

```java
public static int fibonacci(int n) {
    if (n <= 0) {
        return 0;
    } if (n == 1 || n == 2) {
        return 1;
    }
    int firstNumber = 1;
    int secondNumber = 1;
    int result = 0;
    for (int i = 2; i < n; i++) {
        result =  firstNumber + secondNumber;
        firstNumber = secondNumber;
        secondNumber = result;
    }
    return result;
}
```

上面的时间复杂度只有 $O(n)$，我们测试上面程序计算斐波那契数列的第 $45$ 项所需的时间，如下

```java
1134903170
0 ms
```

所需的时间连 `1 ms` 都不需要，速度相比上面提高的不是一星半点。

> 题目：青蛙跳台阶。一只青蛙一次可以跳上 $1$ 级台阶，也可以跳上 $2$ 级台阶。求该青蛙跳上一个 $n$ 级的台阶总共有多少种跳法。

其实这个问题仔细想想就可以发现，这道问题就是斐波那契数列的一个变体。考虑第 $n$ 级台阶，青蛙最后一步到达第 $n$ 级台阶只有两种方法，从 $n - 1$ 级跳 $1$ 级，或者从 $n - 2$ 级跳 $2$ 级，设青蛙跳上一个 $n$ 级台阶有 $f(n)$ 种跳法，那么可以得到这样的关系式
$$
f(n) = f(n - 1) +f(n - 2)
$$
这个式子不就是斐波那契数列的通项嘛，所以程序的写法也是一样的，不过它们的初始条件不一样，简单分析就可以得到
$$
f(1) = 1 \\\\
f(2) = 2
$$
具体的程序参考上面。

<Disqus />
---
title: 数组中数字出现的次数
author: 熊滔
category: 剑指offer
---

> 题目：一个整型数组里除两个数字之外，其他数字都出现了两次。请编写程序找出这两个只出现一次的数字。要求时间复杂度是 $O(n)$，空间复杂度是 $O(1)$。例如，对于数组 $[2, 4, 3, 6, 3, 2, 5, 5]$，只有 $4$ 和 $6$ 出现了一次，所以输出 $4$ 和 $6$。

这是一道比较难的题目，首先我们考虑，如果数组中只有一个数字只出现一次，其他的数字都出现了两次，怎么找出这个数字? 我们可以使用异或，对于异或操作，如果两个数字相同，那么之间异或的结果就是 $0$，而任何数与 $0$ 异或都是该数本身，所以我们让数组中的每个数字之间相互异或，即可得到那个只出现一次的数字。

那么对于有两个只出现一次的数字，如果我们能够将它分成两组，并且在每组中只有一个只出现一次的数字，那么对每组的数组进行异或，即可找到每组中只出现一次的数字，现在我们现在的问题是如何将数字分为两组，并且使得每组中只有一个数字只出现一次。

我们还是对数组中的元素逐一进行异或，异或后的结果一定有一位为 $1$，比如异或后的结果为 $00000100$，从右边数第三位为 $1$，因为其他相同数字异或的结果为 $0$，这个异或结果就是相当于那两个只出现一次的数字进行异或，有一位数字出现为 $1$，说明这一位它们不同，我们就根据从右边数的第一个为 $1$ 的位来划分为两组，对于相同的数字，它们这一位是相同的，也就是说，两个相同的数一定会被划分到同一组，而那两个只出现一次的数一定会被划分到不同组。

```java
// 找到数的二进制表示从右边数 1 第一次出现的位置，从 0 开始
private static int findFirstBitIs1(int number) {
    int flag = 1;
    int index = 0;
    while ((number & flag) != 0 && index < 32) {
        flag = flag << 1;
        index++;
    }
    return index;
}
// 判断在 index 处二进制是否为 1
private static boolean isBit1(int number, int index) {
    int flag = 1 << index;
    return (number & flag) != 0;
}
public static int[] findNumAppearOnce(int[] data) {
    if (data == null || data.length < 2) {
        throw new RuntimeException("传入的数字错误");
    }
    // 首先将数组中的元素进行异或
    int resultOR = 0;
    for (int i = 0; i < data.length; i++) {
        resultOR ^= data[i];
    }
    // 右边第一次 1 出现的位置
    int firstBit1 = findFirstBitIs1(resultOR);
    int num1 = 0;
    int num2 = 0;
    for (int i = 0; i < data.length; i++) {
        // 根据该位是否为 1 分为两组
        if (isBit1(data[i], firstBit1)) {
            num1 ^= data[i];
        } else {
            num2 ^= data[i];
        }
    }
    return new int[]{num1, num2};
}
```

> 题目：在一个数组中除一个数字只出现一次外，其他数字都出现了三次。请找出那个只出现一次的数字。

在这里我们不能使用异或来解决问题了，但是我们还是可以考虑使用位运算的思路来解决问题。如果一个数字出现了三次，那么对于二进制来说，它的每一位也就出现了三次，如果把他们二进制表示的每一位都加起来，那么每一位的和就一定能被 $3$ 整除。例如，$4$ 的二进制表示为 $0000 0100$，如果它出现了三次，我们将它的每一位都加起来 $0000 0300$，它的每一位都能够被 $3$ 整除。

如果我们将数组中所以数字的二进制表示的每一位都加起来，然后对每一位都对 $3$ 求余，最后得到的二进制表示就是那个只出现一次的数字

```java
public static int findAppearOnceWithBit(int[] data) {
    if (data == null || data.length == 0) {
        throw new RuntimeException("wrong input");
    }
    // 使用 32 位的数组存储二进制表示每一位的和
    int[] bitSum = new int[32];
    for (int i = 0; i < data.length; i++) {
        // 统计数字二进制表示的每一位
        int mask = 1;
        for (int j = 31; j >= 0; j--) {
            int bit =  (data[i] & mask);
            if (bit != 0) {
                bitSum[j] += 1;
            }
            mask = mask << 1;
        }
    }
    int result = 0;
    for (int i = 0; i < 32; i++) {
        result = result << 1;
        // 每一位对 3 求余
        result += bitSum[i] % 3;
    }
    return result;
}
```

<Disqus />
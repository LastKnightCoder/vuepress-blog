---
title: 数据流中的中位数
author: 熊滔
category: 剑指offer
---

> 题目：如何得到一个数据流中的中位数? 如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

我们使用两个堆来存储这些数据，一个最大堆，一个最小堆。我们首先随便往一个堆中存入一个数据，然后遍历数组，如果数组中的数字小于最大堆的堆首元素，那么将这个数字添加到最大堆中，如果大于最大堆的堆首元素，那么将元素添加到最小堆中，这样的添加方法可以保证最小堆中的元素始终大于最大堆中的元素。

这样的方法可以使得数组中的元素分为两堆，如果这两个堆中元素的数目相同或者另一个堆中只比另一个堆多一个元素。例如，如果数组中元素的个数是偶数个，如果最大堆中的元素和最小堆中的元素相同，那么中位数就是两个堆首的平均值(最大堆的堆首是该堆中的最大值，最小堆的堆首是该堆中的最小值)；如果数组中元素的个数是奇数，那么就会有一个堆比另一个堆多出一个元素，假设最大堆比最小堆多一个元素，那么中位数就是最大堆的堆首元素。

所以我们在向两个堆中添加元素时，要使得两个堆中元素个数的差值不能大于 $1$ 个，比如如果向最大堆添加一个元素，使得它们元素个数的差值大于 $1$，那么我们可以将最大堆的堆首添加到最小堆中，这样的添加方式使得最小堆中的所有元素还是大于最大堆中的所有元素，对于最小堆中元素个数多与最大堆的情况，只需要将最小堆的堆首元素添加到最大堆中即可。

```java
public static double getMiddleNumber(int[] data) {
    if (data == null || data.length == 0) {
        throw new RuntimeException("数组为空或null");
    }
    // 最大堆
    Queue<Integer> maxHeap = new PriorityQueue<>((num1, num2) -> num2 - num1);
    // 最小堆
    Queue<Integer> minHeap = new PriorityQueue<>((num1, num2) -> num1 - num2);
    
    // 首先向最大堆中添加一个元素
    maxHeap.add(data[0]);
    
    for (int i = 1; i < data.length; i++) {
        // 如果比最大堆堆首的值小，那么添加到最大堆中，否则添加到最小堆中
        if (data[i] < maxHeap.peek()) {
            maxHeap.add(data[i]);
        } else {
            minHeap.add(data[i]);
        }
        // 如果最大堆元素个数比最小堆元素个数多于 2 个或以上，将最大堆的堆首元素添加到最小堆中
        if (maxHeap.size() - minHeap.size() >= 2) {
            int res = maxHeap.remove();
            minHeap.add(res);
        } else if (minHeap.size() - maxHeap.size() >= 2) {
            // 对最小堆同理
            int res = minHeap.remove();
            maxHeap.add(res);
        }
    }
    // 中位数的求法
    double result;
    if (maxHeap.size() - minHeap.size() > 0) {
        result = maxHeap.peek();
    } else if (maxHeap.size() - minHeap.size() < 0) {
        result = minHeap.peek();
    } else {
        result = ((double)maxHeap.peek() + (double)minHeap.peek()) / 2;
    }
    return result;
}
```



<Disqus />
---
title: 数组中的逆序对
author: 熊滔
category: 剑指offer
---

> 题目：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。例如，在数组 $[7, 5, 6, 4]$ 中，一共存在 $5$ 个逆序对，分别是 $(7, 6)、(7, 5)、 (7, 4)、 (6, 4)$ 和 $(5, 4)$。

最简单的做法就是扫描数组，当访问一个数字时，比较后面有没有数字比它小，如果有的话，则这两个数字就组成了一个逆序对。如果数组的长度为 $n$ 的话，那么时间复杂度将会是 $O(n^2)$。

使用归并排序的思想，我们可以找到 $O(n \log n)$ 的算法，具体如下，我们将数组分为两部分，先统计这两部分内部各自的逆序对，并将各自排序，然后统计这两部分之间产生的逆序对数。我们以数组 $[7, 5, 6, 4]$ 为例

<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/202006301756.svg"/>

下面我们将以数组 $[5, 7]$ 与 $[4, 6]$ 合并为例，讲解如何在合并的过程中统计逆序对数

<img src="https://gitee.com/lastknightcoder/blogimage/raw/master/202007010013.svg"/>


代码如下

```java
public static int inversePairs(int[] data) {
    if (data == null || data.length == 0) {
        return 0;
    }
    return inversePairs(data, 0, data.length - 1);
}

public static int inversePairs(int[] data, int start, int end) {
    if (start == end) {
        return 0;
    }
    
    int mid = start + (end - start) / 2;
    // 数组分为两部分
    int left = inversePairs(data, start, mid);
    int right = inversePairs(data, mid + 1, end);
    
    int p1 = mid;
    int p2 = end;
    int count = 0;
    int[] help = new int[end - start + 1];
    int helpIndex = help.length - 1;
    while (p1 >= start && p2 >= mid + 1) {
        if (data[p1] > data[p2]) {
            count += (p2 - mid);
            help[helpIndex--] = data[p1];
            p1--;
        } else {
            help[helpIndex--] = data[p2];
            p2--;
        }
    }
    while (p1 >= start) {
        help[helpIndex--] = data[p1--];
    } 
    while (p2 >= mid + 1) {
        help[helpIndex--] = data[p2--];
    }
    for (int i = start; i <= end; i++) {
        data[i] = help[i - start];
    }
    return left + right + count;
}
```

<Disqus />
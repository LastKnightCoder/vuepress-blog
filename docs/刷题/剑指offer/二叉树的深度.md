---
title: 二叉树的深度
author: 熊滔
category: 剑指offer
---

> 题目：输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点(含根、叶节点)形成树的一条路径，最长路径的长度为树的深度。二叉树的节点定义如下
>
> ```java
> private static class BinaryTreeNode {
>     BinaryTreeNode left;
>     BinaryTreeNode right;
>     int value;
>     public BinaryTreeNode(int value) {
>         this.value = value;
>         this.left = null;
>         this.right = null;
>     }
> }
> ```

对于一棵树来说，它的深度是它左子树和右子树深度较大的那个加一，即
$$
depth = max [ leftDepth, rightDepth ] + 1
$$
而对于左右子树深度的求法，也是递归的使用上面的方法

```java
public static int getTreeDepth(BinaryTreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftDepth = getTreeDepth(root.left);
    int rightDepth = getTreeDepth(root.right);
    return (leftDepth > rightDepth) ? (leftDepth + 1) : (rightDepth + 1);
}
```

> 题目：输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左、右子树的深度相差不超过 $1$，那么它就是一棵平衡二叉树。

如果我们利用上面一题的成果，在遍历每个二叉树的节点时，同时获取它的左右子树的深度，如果每个节点的左右子树的深度相差不超过 $1$，那么它就是一棵平衡二叉树

```java
public static boolean isBalanced(BinaryTreeNode root) {
    if (root == null) {
        return true;
    }
    int left = getTreeDepth(root.left);
    int right = getTreeDepth(root.right);
    int diff = left - right;
    if (Math.abs(diff) > 1) {
        return false;
    }
    return isBalanced(root.left) && isBalanced(root.right);
}
```

但是这个方法有一个缺点，那就是在计算每个节点左右子树的深度时，会发现很多节点所形成树的深度被计算了多次，所以这种算法的效率不高，我们可以考虑在遍历的过程中将节点所代表的树的高度存储起来，避免不必要的重复计算

```java
public static boolean isBalanced(BinaryTreeNode root) {
    Map<BinaryTreeNode, Integer> depthMap = new HashMap<>();
    return isBalanced(root, depthMap);
}
public static boolean isBalanced(BinaryTreeNode root, Map<BinaryTreeNode, Integer> depthMap) {
    if (root == null) {
        depthMap.put(root, 0);
        return true;
    }
    
    if (isBalanced(root.left, depthMap) && isBalanced(root.right, depthMap)) {
        int leftDepth = depthMap.get(root.left);
        int rightDepth = depthMap.get(root.right);
        
        if (Math.abs(leftDepth - rightDepth) <= 1) {
            int depth = leftDepth > rightDepth ? leftDepth + 1 : rightDepth + 1;
            depthMap.put(root, depth);
            return true;
        }
    }
    
    return false;
}
```

<Disqus />